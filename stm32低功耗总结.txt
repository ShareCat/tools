link：http://www.360doc.com/content/15/1215/09/6828497_520521275.shtml
        http://www.eeworld.com.cn/mcu/article_2017021633737.html



具体要点为：
1、所有IO管脚，如果高阻状态端口是高电平，就设成上拉输入，如果高阻状态是低电平，设成下拉输入，如果高阻是中间状态，设成模拟输入。这个很多人都提到过，必须的。作为输出口就免了，待机你想输出个什么东西，一定要输，硬件上加上下拉就可以了
2、两个晶振输入脚要remap成普通IO！！！使用内部晶振。
3、pwr的时钟要使能，即RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);这个也相当重要
4、关闭jtag口，并设成普通IO；
5、注意助焊膏的质量！！！注意电路板层之间是否进水！！！！掌握这几项要点，再设中断什么的都行，整个世界清静了！！！完全低能耗。






STM32实现低功耗待机总结(电流低至5.7uA)

刚开始进入STOPMode后，整机功耗有300uA的，此时外围其他硬件电路电流已经可以肯定漏电流在nA级，因此调试方向在主芯片，经过实际测试，都是GPIO配置的问题，比如某个GPIO为中断输入，闲置为低电平，而我们配置成了IPU，因此内部的40K上拉就会在这里消耗3/40k =75uA，另外将N.C的GPIO配置成Floating Input，也会有一些漏电流，实际测试漏电流不大;另外将STM32F05x直接PIINtoPIN替代STM32100，所以Pin35,36的PF6,PF7为之前的VCC，GND，因此要相应的配置为IPU，IPD，才不会有拉电流/灌电流;外部不使用晶振，因此必须将其配置为IPU/IPD或者输出Low，如果配置成Floating，实测消耗200uA+的电流，这个特别注意。另外不需要关闭不用的外设的CLK，因为STOPMODE会将内部1.8V的core关闭，因此该步骤不影响功耗。

因此在进入STOPMODE之前，需要做:

1、将N.C的GPIO统一配置为IPU/IPD;

2、检查一些Signal的输入Active是High/Low，相应进行配置为IPD/IPU，即避免在内部上/下拉电阻上消耗电流，而且该电流理论值为VCC/R = 3/40 =75uA;

3、如果外部晶振不使用，必须将GPIO配置为IPU/IPD/PPLow，不允许配置为floating，否则会消耗极大的电流 200uA+;

4*、加入进入STOPMODE前，不允许将PWR的CLK关闭，这部分牵涉低功耗模式，实际测试关闭能用，也能唤醒，但是电流会增加10uA+;

5、配置GPIO为输出时，根据输出的常态选择上拉/下拉，如闲置输出为0，则配置为下拉，输出闲置为1，则配置上拉;

6、另外特别说明的是->从Stopmode唤醒后，系统会自动切换到HSI，如果进入前使用的是外部晶振/PLL(PLL的clksource = HSI/HSE)因此必须调用System_Init()，对RCC重新初始化，否则唤醒后主频发生改变，会影响系统;